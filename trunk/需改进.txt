1.长连接方式也会超时（在没有任何消息传输时）
2.StreamingXHR方式reqponseText中会保存所有发送过的信息，即连接时间超长reqponseText信息就越大(雪球效应).
3.用户连接后，立即退出需要时间，原因是连接成功后没有立即给予响应，应立即给出连接成功响应(问题已解决)

主要业务对象应提供相应的工产方法给用户使用，来得到实体，这样有利于扩展
上下文对象应该也由一个Loader或工场方法生成
后期可扩展一个comet.clinet包，用于支持在远程项目中对消息服务进行调用（授权后）。
集成到应用中，可独立服务器部署，可集群部署

配置应抽像出文件，可以是propty，也可以是XML，若XML则需DTD
对servlet3.0进行支持，包括实现和注入容器的方式（利用动态配置）
用文件来存储长时间未送达的离线消息,可配置在badCach中的元素数量
支持上传文件


可增加ExpiresCache<K extends Object,V extends Object>
ExpiresCache构造时可以设置过期时间截和检测频率

msg.setState(2);//TODO:改成常量或协议
msg.setStateText("连接成功");

在Engine上提供一个异常处理中心，异常事件中带有异常类和正在处理的connection
异常的统一转换与本地化
国际化语言包，可用于抛出异常时的错误描述信息。

完成注释
配置方式改为XML
支持注解配置

定时线程如果出错可调用Context的一个方法，Context再把异常转给Engine转化为异常事件

需整理一个Engine的接口
梳理异常并转为Engine的ErrorEvent

连接超时检查需更换方法(连接过期时间一定要大于超时时间，这有问题),Fixed:加入了连接状态的判断
不知道为什么FF会在第二次发启重边时失效，不连了
自动模式下,dying会有空指针异常
在dying时按request有时不能准确找到connction，设置不了state，从而就会有连接永远删除不掉
离开页面时向服务器发drop请求没做
connector.js在new时好像执行了两次，这也可能是有两个end的原因
JS.on不好用，在connector.js
在CometMessage中加一个应用程序通道标识，分发给不同的应用监听，发送的时候加入通道号

IE与Apple会执行两次beforeStop和stop事件
Comet与Apple在beforeunload之前发出的请求没有到达服务器端
只有IE能稳定发出drop事件，Comet哦而也可以
整理服务器端与客户端输出的调试信息

IE下连接、断开、再连接就连接不上。
FireFox下连接一段时间会出现The full stack trace of the root cause is available in the Apache Tomcat错误，多次重连之后会导致服务器宕机，使其它连接停止工作。
定时检查过期时间改为独立线程去检查（考虑使用线程池技术）
将所有服务器端事件统一在CometEngine中。
对于新应用的注册服务
如何注册一个新的应用，如何扩展新应用的servlet
Connector换为POST方式Send数据