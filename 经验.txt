XHR在请求一个地址时不会自动的断开，除非收到服务器端发过来的超时状态，若请求地址根本不可达，那么将一直等待。
XHR向服务器发送请求的过程当中，只有服务器从未给出过任何的数据响应时，才会成功接收到408状态（FF除外）。
即使是长连接（Streaming）也不要一直保持不放，这样会使客户端接收的数据越来越多，造成内存溢出。

异常处理：
http://tech.e800.com.cn/articles/2009/79/1247105040929_1.html
http://onjava.com/pub/a/onjava/2003/11/19/exceptions.html

异常转为异常事件
类单一职责
类与类之间的调用关系能单向则单向，双向的调用耦合性太强，不利于维护与改进
如Engine调用Sender，Sender从不调用Engine，在sendCacheMessage方法为例
protectd用法：例Obserble中的关于增加、删除事件的方法。只允许子类使用，而不允许公共调用
友员用法：例Engine中的sendCacheMessage调用了Sender的getCacheMessage友员方法

java事件模式分类
起因
一个动作发生后，希望使用者可以参与到动作的处理当中
您可以加一个默认处理函数，让用设置进来或重写，但这只够一个人用，即模板模式
你可以加一张列表，然后需要处理的人都把自己的函数注册进来，这就是一个观察者模式
但这只能监听一个动作，即只能对一个事件进行监听
那么我们可以对每个动作/事件对应一张注册列表，发生相应动作时只触发动作对应的注册列表中的侦听函数，这就形成了事件模型
结果
1.不同事件，不同回调，但注册监听方法不统一
提供不同事件注册方法来监控不同的事件，回调函数灵活变化，如GWT,SWing,
2.提供单一事件，统一的注册回调方法，单一的回调函数，在统一事件中含义子类型来告诉回调具体发生了什么事情，如Servlet容器、TomcatComet
3.提供不同的事件，不同回调，统一的注册监听方法
使用经验

事件分发过程可以被终断
触发回调需要倒序
某此引发事件的动作可以被终止
引发事件的对象可以设置挂起事件的分发，待挂起被解除后继续事件分发

软件危机从未过去
单一文件的编程，问题没有复用机制
面向过程提供了一种可以复用的可能，但缺少了一种管理复用的机制。问题是当复用很多时很难管理，不便记忆，不便扩展
软件危机的根源不是因为使用面向过程的编程方法，而是因为人们还没有找到管理巨型代码的方法
面向对象技术的出现，为解决管理巨型代码问题（复用、扩展、管理冲突）提供了很好的解决方案
但这一切的一切都需要使用者懂得去使用，懂得如何复用、扩展、管理冲突
如果不懂会如何？——依然会产生软件危机
只有懂得才具备开发巨型代码的能力，对复用要懂得 组织、管理、扩展 ，即设计

如何学习设计模式
理解每种设计模式所能解决的问题才是关键（才懂得用、懂得实现）
常见错误：有人拿代码与设计模式所提供的代码进行比较，设计上完全一样，才认为是设计模式，这是不准确的

几大块机制
Comet核心的工作原理
参数配置和CometContext
协议定义
国际化方案

IE的xhr对象abort一次就无法再次使用了。
abort的时候会重置xhr对象的各种状态，包括responseText